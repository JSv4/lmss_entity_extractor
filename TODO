# SALI-E: Legal Matter Specification Standard Entity Recognizer

## Project Overview

We are developing an open-source software project, SALI-E, which will be published on GitHub under the MIT License. SALI-E applies the Legal Matter Standards Specification ontology (LMSS) in OWL format to text documents. The project uses Python, FastAPI, HTML, and JavaScript, leveraging open-source libraries and models. The goal is to extract relevant features from documents using Natural Language Processing (NLP) and Named-Entity Recognition (NER) based on the LMSS ontology.

## Plan: LMSS Entity Recognizer

### 1. Ontology Analysis and Preprocessing

#### 1.1. Parse the LMSS ontology:

- Extract classes, hierarchical relationships, attributes, and inter-class relationships.
- Use `rdflib` for robust RDF/OWL parsing.
- Store the ontology structure and embeddings in an RDF graph using `rdflib`.
- The IRI is the unique identifier and has this format: <owl:Class rdf:about="http://lmss.sali.org/A35ng-FGRcus0Cc0pYFhYA">

#### 1.2. Create a searchable index:

- Include: rdf:about, rdfs:label, description, rdfs:seeAlso, skos:altLabel, skos:definition, skos:example, skos:prefLabel
- Store this information within the RDF graph structure.

#### 1.3. Enrich the index with vector embeddings:

- Generate embeddings for the following annotations: rdfs:label, description, rdfs:seeAlso, skos:altLabel, skos:definition, skos:example, skos:prefLabel, for semantic similarity matching.
- Store embeddings as separate additional properties on the nodes in the RDF graph.
- Use the 'all-MiniLM-L6-v2' model for generating embeddings.

#### 1.4. Identify and prioritize high-level parent classes:

- Programmatically identify direct children of `OWL:Thing` (currently 25 high-level parents).
- Ignore the parent class called 'ZZZ - SANDBOX: UNDER CONSTRUCTION'.
- Use these parent classes downstream to improve classification and enable async processes by parent branch.

#### 1.6. Implement efficient storage and retrieval:

- Save the parsed ontology data to a JSON file for quick access.
- Save the full RDF graph, including embeddings, to a Turtle (.ttl) file.
- Implement a file hashing mechanism to check for ontology updates.

### 2. Entity Extraction and Classification Process

#### 2.1. Implement general-purpose NER:

- Use spaCy's `en_core_web_sm` model to identify potential entities.

#### 2.2. Implement keyword extraction:

- Use TF-IDF to extract important keywords that might have been missed by NER.

#### 2.3. Classify extracted terms into ontological branches:

- UNDER REVIEW
- Implement a similarity threshold to filter out entities and keywords not closely related to the LMSS ontology.
- Distinguish between NER-extracted entities and TF-IDF-extracted keywords in the classification process.

#### 2.4. Implement fuzzy matching:

- Use fuzzy string matching (e.g., Levenshtein distance) to match entities with branch labels.
- Set a fuzzy matching threshold to determine successful matches.

#### 2.5. Combine semantic and fuzzy matching:

- Attempt semantic matching first, then fall back to fuzzy matching if semantic matching fails.
- Return the match type (semantic or fuzzy) along with the matched entity and branch.

#### 2.6. Filter and refine results:

- Remove entities and keywords that do not meet either the similarity threshold or the fuzzy matching threshold with any branch.
- Identify features that are classifiable under the LMSS ontology.

#### 2.7. Log unmatched terms:

- Keep track of entities and keywords that couldn't be matched for potential ontology expansion.

### 3. Ontology Matching

#### 3.1. Graph-based matching algorithm:

- Leverage the ontology's structure for matching using SPARQL queries on the RDF graph.

#### 3.2. Multiple matching techniques:

- Use string matching (e.g., Levenshtein distance, fuzzy matching).
- Leverage word embeddings for semantic similarity.

### 4. Hierarchical Classification

#### 4.1. For matched entities, traverse the ontology hierarchy:

- Identify parent classes and return them for context.
- Implement a confidence-based pruning mechanism to avoid overly general classifications.

### 5. User-Driven Class Selection

#### 5.1. Allow users to select specific classes or branches:

- Implement a filtering mechanism for entities matching user-selected classes or subclasses.

### 6. Confidence Scoring

#### 6.1. Develop a scoring system:

- Based on string similarity, semantic similarity, and contextual relevance.
- Incorporate both semantic similarity scores and fuzzy matching scores.

### 7. Visualization

#### 7.1. Create a visual representation of extracted entities:

- Show their place in the ontology hierarchy.
- Display relationships to other entities using a force-directed graph layout.
- Implement zooming and panning features for large ontologies.

## Implementation Outline

### Ontology Preprocessing:

- Enhance `EnhancedLMSSOntologyParser` to use `rdflib` for storing the ontology and embeddings.
- Implement efficient indexing and querying using SPARQL.
- Add functionality to generate and store branch embeddings.
- Implement file hashing and checking for ontology updates.

### Entity Extraction and Classification:

- Develop `EntityExtractor` using spaCy for NER and TF-IDF for keyword extraction.
- Implement classification method using branch embeddings and cosine similarity.
- Add fuzzy matching using fuzzywuzzy library.
- Implement filtering mechanism based on similarity and fuzzy matching thresholds.

### Document Loader:

- Use `Unstructured` or `PyPDF2` for PDF handling.

### API Development (FastAPI):

- Endpoint for document upload.
- Endpoint for ontology class selection.
- Endpoint for retrieving extracted and matched entities.
- Endpoint for detailed entity/class information.
- Implement GraphQL API for flexible querying.

### Front-End Development (HTML/JavaScript):

#### 6.1. Text input field.

#### 6.2. Document uploader (with PDF-to-text conversion).

#### 6.3. Interface for selecting ontology branches.

#### 6.4. Process initiation button.

#### 6.5. Results table displaying:

- Document Title
- Span Start
- Span End
- Text
- Parent Class
- Matching Class
- IRI
- Match Type (Semantic or Fuzzy)
- Confidence Score

#### 6.6. Interactive visualization of selected class node, its parents, and children (up to the root and down).

#### 6.7. JSON download button for full classification results.

## Project Structure

```
sali-e/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── lmss_ontology_parser.py
│   ├── entity_extractor.py
│   ├── run_embeddings.py
│   └── run_entity_extraction.py
├── static/
│   └── js/
│       └── main.js
├── templates/
│   └── index.html
├── tests/
│   ├── test_lmss_ontology_parser.py
│   └── test_entity_extractor.py
├── requirements.txt
├── README.md
└── Dockerfile
```

## Next Steps

1. Implement and test the `EnhancedLMSSOntologyParser` with all the described features.
2. Develop and test the `EntityExtractor` with both semantic and fuzzy matching capabilities.
3. Create the `run_embeddings.py` script to handle ontology processing and branch embedding generation.
4. Refine the `run_entity_extraction.py` script to focus on entity extraction and classification.
5. Develop the FastAPI endpoints for the backend.
6. Create the front-end interface using HTML and JavaScript.
7. Implement visualization features for entity relationships and ontology structure.
8. Conduct thorough testing and optimization of the entire pipeline.
9. Document the project, including usage instructions and API documentation.
10. Prepare for open-source release on GitHub under the MIT License.
